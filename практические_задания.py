# -*- coding: utf-8 -*-
"""Практические задания.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bx_s7wgh0WxhT78LeqynTwSKzjlitGaQ
"""

# Задание 1. Исправиленный код
#Создаем суперкласс.
class SuperClass():

    # Конструктор суперкласса.
    def __init__(self, num):
        self.num = num

    # Метод суперкласса.
    def get_num(self):
        print(self.num)

#Создаем подкласс
class SubClass(SuperClass):

    # Конструктор подкласса.
    def __init__(self, num=0):
        # Вызываем конструктор суперкласса.
        super().__init__(num)
        print('Экземпляр создан!')

# Создаем 1-й экземпляр подкласса
obj_1 = SubClass()

# Выводим значение атрибута
print(obj_1.num)

# Создаем 2-й экземпляр подкласса
obj_2 = SubClass(5)

# Выводим значение атрибута
obj_2.get_num()

#Задание 2. Создайте простейший в мире класс SimplePass. Затем создайте экземпляр класса и выведите на экран его тип.

# Создаем класс SimplePass
class SimplePass:
    pass

# Создаем экземпляр класса
simple_pass = SimplePass()

# Выводим тип экземпляра
print(type(simple_pass))

#Задание 3

#Класс A

class A:
    '''Класс A'''
    def set_a(self, value):
        self.a = value
    
    def get_a(self):
        return self.a

# Выводим документацию класса
print(A.__doc__)

# Создаем первый экземпляр класса
a1 = A()
a1.set_a(10)
print(a1.get_a())  # Выводим значение атрибута a при помощи методов

# Создаем второй экземпляр класса
a2 = A()
a2.a = 20
print(a2.a)  # Выводим значение атрибута a при помощи прямого доступа

# Задание 4

# Класс B

class B:
    '''Класс B'''
    
    def __init__(self, b):
        self.b = b
    
    def get_b(self):
        return self.b

# создание экземпляра класса B
obj = B(10)

# вывод значения атрибута b
print(obj.get_b())

# Задание 5
# Класс C

class A:
    '''Класс A'''

    def __init__(self, a):
        self.set_a(a)

    def set_a(self, a):
        self.a = a

    def get_a(self):
        return self.a


class B:
    '''Класс B'''

    def __init__(self, b):
        self.b = b

    def get_b(self):
        return self.b


class C(A, B):
    '''Класс C = A + B'''

    def __init__(self, a, b, c):
        super().__init__(a)
        B.__init__(self, b)
        self.set_c(c)

    def set_b(self, b):
        self.b = b

    def set_c(self, c):
        self.c = c

    def get_c(self):
        return self.c

# Выводим документацию класса C
print(C.__doc__)

# Создаем экземпляр класса C
obj = C(1, 2, 3)

# Выводим значения атрибутов экземпляра obj
print(obj.get_a())
print(obj.get_b())
print(obj.get_c())

# Задание 6

# Класс D

class D:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @staticmethod
    def stat_print_dict(obj):
        print(obj.__dict__)

    @classmethod
    def cls_print_dict(cls):
        print(cls.__dict__)


# Создаем экземпляр класса D
obj = D(1, 2, 3)

# Вызываем метод stat_print_dict из экземпляра obj
obj.stat_print_dict(obj)

# Вызываем метод cls_print_dict из класса D
D.cls_print_dict()

# Различие в использовании методов заключается в том, что метод stat_print_dict 
# принимает объект класса D в качестве аргумента и выводит на экран словарь его атрибутов, 
# а метод cls_print_dict вызывается на классе D и выводит на экран словарь атрибутов самого класса. 
# Оба метода не изменяют состояние объектов, поэтому их можно вызывать из экземпляра класса или из
# самого класса. Однако метод cls_print_dict также может быть унаследован и использован в подклассах.

# Задание 7

class D:
    a = 1
    b = 'Hello'

    @staticmethod
    def stat_print_dict(obj):
        print(obj.__dict__)

    @classmethod
    def cls_print_dict(cls):
        print(cls.__dict__)


class E(D):
    e = 'Класс E'


# Создаем экземпляр класса D
obj_1 = D()

# Выводим словарь атрибутов класса D из экземпляра obj_1
obj_1.stat_print_dict(obj_1)
obj_1.cls_print_dict()

# Создаем экземпляр класса E
obj_2 = E()

# Выводим словарь атрибутов класса E из экземпляра obj_2
obj_2.stat_print_dict(obj_2)
obj_2.cls_print_dict()

# Различие в использовании методов stat_print_dict и cls_print_dict заключается в том, что
# первый метод принимает на вход экземпляр класса, а второй метод не принимает никаких аргументов и 
# работает только с атрибутами класса.

# При создании экземпляра класса E наследуется атрибут stat_print_dict класса D, 
# который вызывает метод __dict__ для экземпляра класса E и выводит пустой словарь, так как в E нет 
# своих атрибутов, отличных от унаследованных. А метод cls_print_dict выводит словарь атрибутов класса E, который содержит только атрибут e.

# Задание 8

# Класс F

class F(A):
    """
    Объект класса F
    """

    def __init__(self, a, b):
        super().__init__(a)
        self.b = b

    def set_a(self, value):
        """
        Устанавливает значение атрибута a.

        Args:
            value: новое значение атрибута a.

        Returns:
            None.
        """
        super().set_a(value)
        # A.set_a(self, value)
        # super(F, self).set_a(value)
        print('Атрибут a установлен!')

# Создаем экземпляр класса F
obj = F(1, 2)

# Выводим документацию экземпляра obj
print(obj.__doc__)

# Устанавливаем значение атрибута a и выводим его на экран
obj.set_a(10)
print(obj.get_a())

# Задание 9

class Counter:
    def __init__(self, start=0, min_val=0, max_val=10):
        self.start = start
        self.min_val = min_val
        self.max_val = max_val
        self.current_val = start
    
    def set_values(self, start=None, min_val=None, max_val=None):
        if start is not None:
            self.start = start
            self.current_val = start
        if min_val is not None:
            self.min_val = min_val
        if max_val is not None:
            self.max_val = max_val
    
    def increment(self, step=1):
        new_val = self.current_val + step
        if new_val > self.max_val:
            self.current_val = self.max_val
            print("Error: Counter value exceeded maximum limit!")
        else:
            self.current_val = new_val
            print("Counter value incremented!")
    
    def decrement(self, step=1):
        new_val = self.current_val - step
        if new_val < self.min_val:
            self.current_val = self.min_val
            print("Error: Counter value below minimum limit!")
        else:
            self.current_val = new_val
            print("Counter value decremented!")

# Создание экземпляра счетчика со значениями по умолчанию
counter = Counter()
print("Counter values (default): start={}, min_val={}, max_val={}, current_val={}"
      .format(counter.start, counter.min_val, counter.max_val, counter.current_val))

# Проверка работы счетчика в пределах диапазона
print("\nIncrementing counter within range:")
for i in range(counter.start, counter.max_val+1):
    counter.increment()
    print("Current counter value:", counter.current_val)

# Переустановка счетчика с отрицательной нижней границей и положительной верхней границей
counter.set_values(start=5, min_val=-10, max_val=10)
print("\nCounter values (updated): start={}, min_val={}, max_val={}, current_val={}"
      .format(counter.start, counter.min_val, counter.max_val, counter.current_val))

# Проверка работы счетчика в пределах диапазона
print("\nDecrementing counter within range:")
for i in range(counter.start, counter.min_val-1, -1):
    counter.decrement()
    print("Current counter value:", counter.current_val)

# Задание 10

import math

class Circle:
    cm_in_m = 100  # константа для перевода метров в сантиметры

    @staticmethod
    def convert_length(length, unit):
        """
        Статический метод для перевода метров в сантиметры или наоборот

        :param length: длина в метрах или сантиметрах
        :param unit: единица измерения ('m' для метров, 'cm' для сантиметров)
        :return: длина в противоположной единице измерения
        """
        if unit == 'm':
            return length * Circle.cm_in_m
        elif unit == 'cm':
            return length / Circle.cm_in_m
        else:
            raise ValueError("Invalid unit: {}. Use 'm' or 'cm'".format(unit))

    def __init__(self, radius):
        """
        Конструктор, инициализирующий радиус окружности

        :param radius: радиус окружности
        """
        self.radius = radius

    def get_length(self):
        """
        Метод для получения длины окружности

        :return: длина окружности
        """
        return 2 * math.pi * self.radius

    def get_area(self):
        """
        Метод для получения площади окружности

        :return: площадь окружности
        """
        return math.pi * self.radius ** 2

# Создание экземпляра класса Circle
radius = 2.55  # радиус окружности в метрах
circle = Circle(radius)

# Расчет и вывод длины и площади окружности в сантиметрах
length_cm = Circle.convert_length(circle.get_length(), 'm')
area_cm2 = Circle.convert_length(circle.get_area(), 'm') ** 2
print("Длина окружности: {:.2f} см".format(length_cm))
print("Площадь окружности: {:.2f} кв. см".format(area_cm2))

# Задание 11

class A:
    def plus(self, a, b):
        res = a + b
        self.last_res = [a, b, res]
        return res

class B:
    def minus(self, a, b):
        res = a - b
        self.last_res = [a, b, res]
        return res

class C:
    def __init__(self):
        self.plus_obj = A()
        self.minus_obj = B()

obj = C()

a = 5
b = 3

print(obj.plus_obj.plus(a, b))  # сумма чисел
print(obj.plus_obj.last_res)   # последний результат операции сложения

print(obj.minus_obj.minus(a, b))  # разность чисел
print(obj.minus_obj.last_res)   # последний результат операции вычитания

# Задание 12

class Сотрудник:
    def __init__(self, имя, должность=None, оклад=0):
        self.имя = имя
        self.должность = должность
        self.оклад = оклад

    def повысить_оклад(self, насколько):
        self.оклад = round(self.оклад * (1 + насколько), 2)

    def __str__(self):
        return f"Имя: {self.имя}\nДолжность: {self.должность}\nОклад: {self.оклад}"


class Менеджер(Сотрудник):
    def повысить_оклад(self, насколько):
        бонус = self.оклад * 0.25
        self.оклад = round(self.оклад * (1 + насколько + бонус), 2)


иван_менеджер = Менеджер("Иван", "менеджер", 1700)
иван_менеджер.повысить_оклад(0.335)
print(иван_менеджер)